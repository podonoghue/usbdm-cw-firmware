/* MK, MKL, MKE version
 * Linker script based on example scripts provided with ARM Ltd GCC
 *
 * It references the following symbols, which must be defined in code:
 * 
 *      Reset_Handler : Entry of reset handler
 * 
 * 
 * It defines the following symbols, which code can use without definition:
 *      __exidx_start
 *      __exidx_end
 *      __etext
 *      __data_start__
 *      __preinit_array_start
 *      __preinit_array_end
 *      __init_array_start
 *      __init_array_end
 *      __fini_array_start
 *      __fini_array_end
 *      __data_end__
 *      __bss_start__
 *      __bss_end__
 *      __end__
 *      end
 *      __HeapBottom
 *      __HeapLimit
 *      __StackLimit
 *      __StackTop
 *      __stack
 */
 
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
SEARCH_DIR(.)

/* ---- <<< Use Configuration Wizard in Context Menu >>> ---- */

/* <o> Stack Size
   <i> Required amount of stack space  
   <0x0-0x4000> 
*/
__stack_size = 0x1000;

/* <o> Minimum Heap Size 
   <i> Actual heap may be larger as it fills all unused RAM up to STACK
   <0x0-0x4000> 
*/
__heap_size  = 0x1000;

/* <o0> Size of RAM region reserved for bit-band or bit-manipulation-engine (bytes) 
   <i>  Space is allocated in SRAM_U memory region
   <i>  Each byte as also mapped to 8 words in .bitband memory region (if present)
   <i>
   <i>  C Example:
   <i>    // Variable allocated in bitband/bme accessible region (SRAM_U)
   <i>    // May be uint8_t, uint16_t or uint32_t
   <i>    __attribute__ ((section(".sram_u"))) uint32_t variable;
   <i>
   <i>    // Each word of array maps to an individual bit in bit-band
   <i>    __attribute__ ((section(".bitband"))) uint32_t variable_bits[8*sizeof(variable)];
   <i>
   <i>  See bme.h and bitband.h for more information
*/
__sram_u_size = 0;
   
/*
 * Memory Map generated by USBDM New Project Wizard for MK20DX128M5
 *
 * Relocated to 0x8000 for OpenSDA V1
 */
MEMORY
{
  flexNVM        (rx)  : ORIGIN = 0x10000000, LENGTH = 0x00008000
  bitband        (rw)  : ORIGIN = 0x22000000, LENGTH = 0x02000000
  aips0          (rw)  : ORIGIN = 0x40000000, LENGTH = 0x00080000
  aips1          (rw)  : ORIGIN = 0x40080000, LENGTH = 0x0007F000
  gpio           (rw)  : ORIGIN = 0x400FF000, LENGTH = 0x00001000
  gpioBitband    (rw)  : ORIGIN = 0x42000000, LENGTH = 0x02000000
  peripherals    (rw)  : ORIGIN = 0xE0000000, LENGTH = 0x00100000
  rom            (rx)  : ORIGIN = 0x00008000, LENGTH = 0x00020000-0x8000
  ram            (rwx) : ORIGIN = 0x1FFFE000, LENGTH = 0x00004000
  /* Guard region above stack for GDB */
  gdbGuard       (r)   : ORIGIN = 0x20002000, LENGTH = 0x00000020
};

ENTRY(Reset_Handler)

PROVIDE(__stack_size__ = __stack_size);
PROVIDE(__heap_size__  = __heap_size);

PROVIDE(__HardReset = Reset_Handler);

/* Needed for -nostartfiles linker option call main directly */
PROVIDE(_start = main);

SECTIONS
{
   .interrupts :
   {
      __flash_start = .;

      /* Vector table */
      __VECTOR_TABLE = .;
      KEEP(*(.interrupt_vectors))
      KEEP(*(.isr_vector))         /* KDS vector table */
      /* Make sure we pulled in at least a reset vector.  */
      ASSERT (. != __flash_start, "No reset vector found");
      __VECTOR_TABLE_END = .;
      
      /* Uncomment to Emit a Bootloader configuration if present */
      /*
      . = __flash_start + 0x3C0;
      KEEP(*(.bootloader_configuration))
      */
      
      /*
      OpenSDA doesn't use security area 
      Emit a Security field
      . = __flash_start + 0x400;
      KEEP(*(.security_information))
      ASSERT (. == __flash_start + 0x410, "No Freescale security information");
      */
      KEEP(*(.FlashConfig))    /* KDS Flash Configuration Field (FCF) */
    } > rom

/* Size of RAM vector table (if needed) */
M_VECTOR_RAM_SIZE = DEFINED(__ram_vector_table__) ? (__VECTOR_TABLE_END - __VECTOR_TABLE) : 0x0000;

   .text :
   {
      *(.text)                 /* .text sections (code) */
      *(.text*)                /* .text* sections (code) */
      *(.rodata)               /* .rodata sections (constants, strings, etc.) */
      *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
      KEEP(*(.init))
      KEEP(*(.fini))

      /* .ctors */
      __CTOR_LIST__ = .;
      KEEP (*crtbegin.o(.ctors))
      KEEP (*crtbegin?.o(.ctors))
      KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
      KEEP (*(SORT(.ctors.*)))
      KEEP (*(.ctors))
      __CTOR_END__ = .;

      /* .dtors */
      __DTOR_LIST__ = .;
      KEEP (*crtbegin.o(.dtors))
      KEEP (*crtbegin?.o(.dtors))
      KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
      KEEP (*(SORT(.dtors.*)))
      KEEP (*(.dtors))
      __DTOR_END__ = .;
      . = ALIGN(4);
      /* preinit data */
      PROVIDE_HIDDEN (__preinit_array_start = .);
      KEEP(*(.preinit_array*))
      PROVIDE_HIDDEN (__preinit_array_end = .);

      . = ALIGN(4);
      /* init data */
      PROVIDE_HIDDEN (__init_array_start = .);
      KEEP(*(SORT(.init_array.*)))
      KEEP(*(.init_array*))
      PROVIDE_HIDDEN (__init_array_end = .);

      . = ALIGN(4);
      /* finit data */
      PROVIDE_HIDDEN (__fini_array_start = .);
      KEEP(*(SORT(.fini_array.*)))
      KEEP(*(.fini_array*))
      PROVIDE_HIDDEN (__fini_array_end = .);

      KEEP(*(.jcr*))

      KEEP(*(.eh_frame*))
    } > rom

   .ARM.extab : 
   {
      *(.ARM.extab* .gnu.linkonce.armextab.*)
   } > rom

   __exidx_start = .;
   .ARM.exidx :
   {
      *(.ARM.exidx* .gnu.linkonce.armexidx.*)
   } > rom
   __exidx_end = .;

   __etext = .;    /* define a global symbol at end of code */
   __DATA_ROM = .; /* Symbol is used by startup for data initialization */

  /* reserve MTB memory at the beginning of data */
  .mtb : /* MTB buffer no0load */
  {
    . = ALIGN(8);
    _mtb_start = .;
    KEEP(*(.mtb_buf)) /* May not referenced by application */
    . = ALIGN(8);
    _mtb_end = .;
  } > ram

  .interrupts_ram :
  {
    . = ALIGN(4);
    __VECTOR_RAM__ = .;
    __interrupts_ram_start__ = .;
    *(.m_interrupts_ram)     
    . += M_VECTOR_RAM_SIZE;
    . = ALIGN(4);
    __interrupts_ram_end__ = .; 
  } > ram

  __VECTOR_RAM = DEFINED(__ram_vector_table__) ? __VECTOR_RAM__ : __VECTOR_TABLE;
  __RAM_VECTOR_TABLE_SIZE_BYTES = __interrupts_ram_end__ - __interrupts_ram_start__;
  
   .data : AT (__etext)
   {
      __data_start__ = .;
      __DATA_RAM = .;
      *(vtable)
      *(.data*)

      . = ALIGN(4);
      /* All data end */
      __data_end__ = .;
   } > ram
   
  /* KDS defines __DATA_END as the end of DATA in ROM */
  __DATA_END = __DATA_ROM + SIZEOF(.data);

   .bss :
   {
      . = ALIGN(4);
      __START_BSS = .;
      __bss_start__ = .;
      *(.bss)
      *(.bss*)
      *(COMMON)
      . = ALIGN(4);
      __bss_end__ = .;
      __END_BSS = .;
   } > ram
    
   /* Minimum HEAP - from top of BSS */
   .heap :
   {
      . = ALIGN(4);
      PROVIDE ( __end__ = . );
      PROVIDE ( end = . );
      PROVIDE ( _end = . );
      __HeapBase = .;
      __heap_addr = .;
      . = . + __heap_size__;
   } > ram

   /* STACK space - between HEAP and end of RAM (or bitband_bytes) */
   PROVIDE ( __sram_u_size = 0 );
   .stack :
   {
      /* Make sure location doesn't move backwards as causes cryptic messages */
      . = MAX( ., ABSOLUTE(ORIGIN(ram) + LENGTH(ram) - __stack_size__ - __sram_u_size - 3));
      . = ALIGN(4);
      __HeapLimit = .;
      __StackLimit = .;
      . = . + __stack_size__;
      __StackTop = .;
   } > ram

   /* 
    * SRAM_U region
    *
    * This area is partitioned from the top of SRAM
    *
    * Each bit in this region maps to a word in the .bitband region (if present)
    * This region is also accessible to BME (if present and supports RAM access) 
    */
   .sram_u (NOLOAD) :
   {
      *(.sram_u)
   } > ram

   /*
    * Bitband region
    *
    * Each word in this region maps to a bit in the .bitband_byte region 
    */
   .bitband (NOLOAD) :
   {
      /* Allocate variables from top of region */
      . = ORIGIN(bitband) + ((ORIGIN(ram) + LENGTH(ram) - __sram_u_size) & 0xFFFFFF) * 32;
      *(.bitband)
   } > bitband
    
  PROVIDE(__stack = __StackTop);
  PROVIDE(__cs3_stack = __StackTop);
  
  /*
   * These are very 'weak' to ensure semi-hosting version 
   * will be used for rdimon.specs option
   */
  PROVIDE(_write = _usbdm_write);
  PROVIDE(_read  = _usbdm_read);

  /*
   RAM Memory map                                            Example
  +----------------------+                                   0x1FFFFF00
  | Micro Trace Buffer   |
  | (if declared)        |
  +----------------------+ __interrupts_ram_start__          0x1FFFFF00+???
  | RAM vector table     |
  | (if declared)        |
  +----------------------+ __data_start__                    0x1FFFFF00+???
  | DATA                 |
  |                      |
  +----------------------+ __data_end__ = __bss_start__      0x1FFFFF68
  | BSS                  |
  |                      |
  +----------------------+ __bss_end__ = __HeapBase          0x1FFFFF84
  | Heap                 |
  | (__heap_size__)      |  (minimum heap)                   (size=0x120)
  +----------------------+                                   0x200000A4
  |//////////////////////|
  +----------------------+ __HeapLimit = __StackLimit        0x200001fc
  | Stack                |
  | (__stack_size__)     |                                   (size=0x100)
  +----------------------+ __StackTop                        0x200002ff
  | Bitband/BME (sram_u) |
  | (__sram_u_size)      |                                   (size=1)
  +----------------------+                                   0x20000300
  
  */
}
